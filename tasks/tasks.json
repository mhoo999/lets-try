{
  "tasks": [
    {
      "id": 1,
      "title": "Next.js 및 TypeScript 프로젝트 세팅",
      "description": "Initialize the project repository with Next.js, TypeScript, and Tailwind CSS as specified in the PRD.",
      "details": "1. Create a new Next.js project with TypeScript support:\n```bash\nnpx create-next-app@latest lets-try --typescript\n```\n2. Install and configure Tailwind CSS:\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n3. Configure Tailwind CSS in tailwind.config.js and globals.css\n4. Set up project structure with folders for components, hooks, utils, and pages\n5. Configure ESLint and Prettier for code quality\n6. Set up deployment configuration for Vercel\n7. Create basic layout components (Header, Footer, Layout)",
      "testStrategy": "1. Verify that the project builds without errors\n2. Confirm that Tailwind CSS is properly configured by testing a sample component\n3. Ensure TypeScript is correctly set up by checking type checking\n4. Test the deployment pipeline to Vercel",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Next.js 설치 및 설정",
          "description": "Set up a new Next.js project with the necessary configurations",
          "dependencies": [],
          "details": "Use create-next-app to initialize a new Next.js project. Configure the basic settings including the app router, CSS modules, and other initial preferences. Verify the installation by running the development server.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "TypeScript와 린트 환경 구축",
          "description": "Configure TypeScript and ESLint for code quality",
          "dependencies": [
            1
          ],
          "details": "Configure tsconfig.json with appropriate TypeScript settings. Install and set up ESLint with recommended rules for Next.js and TypeScript. Add Prettier for code formatting. Create necessary configuration files and scripts in package.json for linting and type checking.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "프로젝트 폴더 구조 설계",
          "description": "Establish the folder structure and organization for the project",
          "dependencies": [
            1,
            2
          ],
          "details": "Create essential directories like components, pages/app (depending on router), utils, styles, public, etc. Set up the basic layout components. Create placeholder files for main sections of the application. Document the project structure in a README file.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "버전 관리(Git) 초기화",
          "description": "Set up Git repository and initial commit",
          "dependencies": [
            3
          ],
          "details": "Initialize Git repository. Create .gitignore file with appropriate rules for Next.js projects. Make initial commit with the project structure. Set up remote repository on GitHub/GitLab/etc. Create development branch for ongoing work. Document branching strategy if applicable.",
          "status": "done"
        }
      ]
    },
    {
      "id": 2,
      "title": "손등 이미지 업로드 및 가이드 구현",
      "description": "Implement the functionality for users to upload hand images and provide a visual guide for proper hand positioning.",
      "details": "1. Create an image upload component with drag-and-drop and file selection capabilities\n2. Implement client-side image validation (file type, size, dimensions)\n3. Add a visual guide component showing the correct hand positioning\n4. Create a preview component to display the uploaded image\n5. Implement responsive design for mobile optimization\n6. Add privacy notice explaining that images are not stored on servers\n\nExample code for image upload:\n```tsx\nconst ImageUpload = () => {\n  const [image, setImage] = useState<File | null>(null);\n  const [preview, setPreview] = useState<string | null>(null);\n  \n  const handleUpload = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (file && file.type.startsWith('image/')) {\n      setImage(file);\n      setPreview(URL.createObjectURL(file));\n    }\n  };\n  \n  return (\n    <div className=\"upload-container\">\n      <div className=\"guide-container\">\n        <img src=\"/hand-guide.png\" alt=\"Hand positioning guide\" />\n        <p>Position your hand as shown in the guide</p>\n      </div>\n      <input type=\"file\" accept=\"image/*\" onChange={handleUpload} />\n      {preview && <img src={preview} alt=\"Preview\" className=\"preview-image\" />}\n    </div>\n  );\n};\n```",
      "testStrategy": "1. Test image upload with various file types, ensuring only images are accepted\n2. Verify preview functionality works correctly\n3. Test responsive design on different mobile devices\n4. Verify that the guide is clearly visible and helpful\n5. Confirm that no image data is sent to any server (network monitoring)",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "레이아웃 핵심 컴포넌트 구현",
          "description": "Implement the header, footer, and main content area components according to the Figma design",
          "dependencies": [],
          "details": "Build the foundational layout structure including the header with navigation, footer with site information, and the main content container. Ensure these components are properly structured for content flow and follow the design specifications. Use Tailwind CSS for styling and ensure proper semantic HTML elements are used.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "재사용 UI 요소 개발",
          "description": "Develop reusable UI components such as buttons, modals, form elements, and cards",
          "dependencies": [
            1
          ],
          "details": "Create a component library of reusable UI elements that maintain consistent styling throughout the application. Include various button states (primary, secondary, disabled), modal windows with overlay effects, form inputs with validation states, and content cards. Document component props and usage examples for team reference.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "반응형 디자인 시스템 구축",
          "description": "Implement a responsive design system that works across mobile, tablet, and desktop viewports",
          "dependencies": [
            1,
            2
          ],
          "details": "Develop a comprehensive responsive design system using Tailwind's breakpoint utilities. Create responsive variants for all components, implement appropriate spacing scales, and ensure text remains readable at all viewport sizes. Test thoroughly on various device sizes and orientations to ensure proper layout adaptation.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "플로우용 플레이스홀더 화면 구현",
          "description": "Implement placeholder screens for the main user journey through the application",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Build skeleton screens for each step in the user flow, including landing page, authentication screens, dashboard, and feature pages. Use the previously created components to assemble these screens. Include basic navigation between screens and ensure the flow matches the intended user journey while maintaining responsive behavior across all devices.",
          "status": "done"
        }
      ]
    },
    {
      "id": 3,
      "title": "MediaPipe Hands 손가락 인식 연동",
      "description": "Integrate MediaPipe Hands library to detect and track finger positions on the uploaded hand image.",
      "details": "1. Install MediaPipe Hands library:\n```bash\nnpm install @mediapipe/hands @mediapipe/drawing_utils @mediapipe/camera_utils\n```\n2. Create a custom hook for hand detection:\n```tsx\nconst useHandDetection = (imageElement: HTMLImageElement | null) => {\n  const [fingerPositions, setFingerPositions] = useState<{finger: string, x: number, y: number}[]>([]);\n  \n  useEffect(() => {\n    if (!imageElement) return;\n    \n    const hands = new Hands({\n      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,\n    });\n    \n    hands.setOptions({\n      maxNumHands: 1,\n      modelComplexity: 1,\n      minDetectionConfidence: 0.5,\n      minTrackingConfidence: 0.5\n    });\n    \n    hands.onResults((results) => {\n      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {\n        const landmarks = results.multiHandLandmarks[0];\n        // Map MediaPipe landmarks to finger positions\n        const positions = [\n          { finger: 'thumb', x: landmarks[4].x, y: landmarks[4].y },\n          { finger: 'index', x: landmarks[8].x, y: landmarks[8].y },\n          { finger: 'middle', x: landmarks[12].x, y: landmarks[12].y },\n          { finger: 'ring', x: landmarks[16].x, y: landmarks[16].y },\n          { finger: 'pinky', x: landmarks[20].x, y: landmarks[20].y }\n        ];\n        setFingerPositions(positions);\n      }\n    });\n    \n    // Process the image\n    const canvas = document.createElement('canvas');\n    canvas.width = imageElement.width;\n    canvas.height = imageElement.height;\n    const ctx = canvas.getContext('2d');\n    ctx?.drawImage(imageElement, 0, 0);\n    const imageData = ctx?.getImageData(0, 0, canvas.width, canvas.height);\n    \n    if (imageData) {\n      hands.send({image: imageData});\n    }\n    \n    return () => {\n      hands.close();\n    };\n  }, [imageElement]);\n  \n  return fingerPositions;\n};\n```\n3. Implement visual indicators (pills) for each detected finger\n4. Add error handling for cases where hand detection fails\n5. Optimize for performance on mobile devices",
      "testStrategy": "1. Test hand detection with various hand images and positions\n2. Verify accuracy of finger position detection\n3. Test with different lighting conditions and backgrounds\n4. Measure and optimize performance on mobile devices\n5. Create test cases for error scenarios (no hand detected, multiple hands, etc.)",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "드래그&드롭/파일 선택 구현",
          "description": "Create a component that allows users to upload images via drag-and-drop or traditional file selection dialog",
          "dependencies": [],
          "details": "Build a reusable component that handles both drag-and-drop functionality and traditional file input selection. Include visual feedback for drag events (hover, drop), handle multiple file attempts appropriately, and ensure cross-browser compatibility. Implement error handling for failed uploads and provide user feedback.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "카메라 촬영 기능 추가",
          "description": "Implement functionality to access device camera for direct photo capture within the application",
          "dependencies": [
            1
          ],
          "details": "Use the MediaDevices API to request camera access, create an interface for capturing photos directly from the camera, handle permission requests and denials gracefully, ensure mobile device compatibility, and provide fallback options when camera access isn't available or permitted.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "이미지 유효성 검사 및 처리",
          "description": "Implement validation for file types, sizes, and dimensions along with basic client-side image processing",
          "dependencies": [
            1,
            2
          ],
          "details": "Validate uploaded images for acceptable file types (JPEG, PNG, etc.), file size limits, and dimension requirements. Implement client-side image processing including basic resizing, compression, and orientation correction. Provide clear feedback to users when validation fails and suggest remedies.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "미리보기 및 위치 가이드 구현",
          "description": "Create an image preview component that shows the uploaded image with positioning guidance for users",
          "dependencies": [
            3
          ],
          "details": "Develop a preview component that displays the uploaded/captured image with visual guides for proper positioning. Include features like zoom, pan, and crop functionality. Implement responsive design to ensure the preview works well across different screen sizes. Add visual indicators or overlays to help users position their images correctly.",
          "status": "done"
        }
      ]
    },
    {
      "id": 4,
      "title": "반지 이미지 관리 및 스토리지 연동",
      "description": "Set up integration with external storage (S3 or Supabase) for ring images and implement the client-side access to these images.",
      "details": "1. Set up external storage (S3 or Supabase) for ring images\n2. Create a data structure for ring information:\n```typescript\ninterface RingInfo {\n  id: string;\n  name: string;\n  imageUrl: string;\n  availableColors: {\n    id: string;\n    name: string;\n    colorCode: string;\n    imageUrl: string;\n  }[];\n}\n```\n3. Implement a client-side service to fetch ring data:\n```typescript\nconst fetchRings = async (): Promise<RingInfo[]> => {\n  // In a real implementation, this would fetch from an API\n  // For MVP, we can use a static JSON file stored in the public directory\n  const response = await fetch('/data/rings.json');\n  return response.json();\n};\n```\n4. Create a context provider for ring data:\n```tsx\nconst RingContext = createContext<{\n  rings: RingInfo[];\n  loading: boolean;\n  error: Error | null;\n}>({ rings: [], loading: false, error: null });\n\nconst RingProvider: React.FC = ({ children }) => {\n  const [rings, setRings] = useState<RingInfo[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  \n  useEffect(() => {\n    fetchRings()\n      .then(data => {\n        setRings(data);\n        setLoading(false);\n      })\n      .catch(err => {\n        setError(err);\n        setLoading(false);\n      });\n  }, []);\n  \n  return (\n    <RingContext.Provider value={{ rings, loading, error }}>\n      {children}\n    </RingContext.Provider>\n  );\n};\n```\n5. Implement image preloading for better performance",
      "testStrategy": "1. Verify that ring images load correctly from external storage\n2. Test with various image sizes and formats\n3. Measure loading performance and optimize if needed\n4. Test error handling when images fail to load\n5. Verify that the ring data structure is correctly implemented",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "MediaPipe Hands 라이브러리 세팅",
          "description": "Initialize and configure the MediaPipe Hands library in the application",
          "dependencies": [],
          "details": "Install MediaPipe dependencies, import the library, and configure initial parameters like maximum number of hands to detect, detection confidence threshold, and tracking confidence threshold. Ensure the library is properly integrated with the application's build system.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "손 랜드마크 검출 시스템 구현",
          "description": "Implement the core functionality to detect hand landmarks from camera input",
          "dependencies": [
            1
          ],
          "details": "Set up the camera input pipeline, connect it to MediaPipe's hand detection model, and implement the processing loop that extracts the 21 hand landmarks per detected hand. Create a system that processes frames at an appropriate rate for real-time interaction.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "랜드마크 데이터 모델 매핑",
          "description": "Transform MediaPipe's landmark output format to the application's internal data representation",
          "dependencies": [
            2
          ],
          "details": "Create a mapping system between MediaPipe's 21-point hand model and the application's data model. Implement normalization of coordinates, handle different hand orientations (left/right), and ensure consistent data flow between detection and the rest of the application.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "시각화 및 예외 처리",
          "description": "Create visual feedback of detected hand points and implement robust error handling",
          "dependencies": [
            3
          ],
          "details": "Develop a visualization layer to display detected hand landmarks for debugging and user feedback. Implement comprehensive error handling for scenarios like no hands detected, poor lighting conditions, partial hand visibility, and tracking failures. Add recovery mechanisms to maintain application stability during detection issues.",
          "status": "done"
        }
      ]
    },
    {
      "id": 5,
      "title": "반지 선택 UI 및 팝업/컬러칩 구현",
      "description": "Implement the UI for selecting rings, including the selectring button, popup modal, and color chip selection according to the Figma design.",
      "details": "1. Create a SelectRing button component that activates after hand image upload\n2. Implement a modal/popup component for ring selection:\n```tsx\nconst RingSelectionModal: React.FC<{\n  isOpen: boolean;\n  onClose: () => void;\n  onSelectRing: (ringId: string, colorId: string) => void;\n}> = ({ isOpen, onClose, onSelectRing }) => {\n  const { rings, loading } = useContext(RingContext);\n  const [selectedRing, setSelectedRing] = useState<string | null>(null);\n  const [selectedColor, setSelectedColor] = useState<string | null>(null);\n  \n  const handleRingSelect = (ringId: string) => {\n    setSelectedRing(ringId);\n    // Default to first color\n    const ring = rings.find(r => r.id === ringId);\n    if (ring && ring.availableColors.length > 0) {\n      setSelectedColor(ring.availableColors[0].id);\n    }\n  };\n  \n  const handleColorSelect = (colorId: string) => {\n    setSelectedColor(colorId);\n  };\n  \n  const handleConfirm = () => {\n    if (selectedRing && selectedColor) {\n      onSelectRing(selectedRing, selectedColor);\n      onClose();\n    }\n  };\n  \n  if (!isOpen) return null;\n  \n  return (\n    <div className=\"modal-overlay\">\n      <div className=\"modal-content\">\n        <h2>Select a Ring</h2>\n        {loading ? (\n          <p>Loading rings...</p>\n        ) : (\n          <>\n            <div className=\"ring-grid\">\n              {rings.map(ring => (\n                <div \n                  key={ring.id} \n                  className={`ring-item ${selectedRing === ring.id ? 'selected' : ''}`}\n                  onClick={() => handleRingSelect(ring.id)}\n                >\n                  <img src={ring.imageUrl} alt={ring.name} />\n                  <p>{ring.name}</p>\n                </div>\n              ))}\n            </div>\n            \n            {selectedRing && (\n              <div className=\"color-selection\">\n                <h3>Select Color</h3>\n                <div className=\"color-chips\">\n                  {rings\n                    .find(r => r.id === selectedRing)?\n                    .availableColors.map(color => (\n                      <div \n                        key={color.id}\n                        className={`color-chip ${selectedColor === color.id ? 'selected' : ''}`}\n                        style={{ backgroundColor: color.colorCode }}\n                        onClick={() => handleColorSelect(color.id)}\n                      />\n                    ))}\n                </div>\n              </div>\n            )}\n            \n            <div className=\"modal-actions\">\n              <button onClick={onClose}>Cancel</button>\n              <button \n                onClick={handleConfirm}\n                disabled={!selectedRing || !selectedColor}\n              >\n                Confirm\n              </button>\n            </div>\n          </>\n        )}\n      </div>\n    </div>\n  );\n};\n```\n3. Implement the name tag component to display selected ring name\n4. Create finger pill components that can be toggled on/off\n5. Implement automatic selection of thumb after initial ring selection\n6. Ensure the modal automatically closes after selection\n7. Style all components according to Figma design",
      "testStrategy": "1. Test the modal opening and closing functionality\n2. Verify that ring and color selection works correctly\n3. Test the automatic thumb selection after initial ring choice\n4. Verify that the name tag updates correctly\n5. Test the UI on various screen sizes for responsive design\n6. Conduct usability testing to ensure the flow is intuitive",
      "priority": "high",
      "dependencies": [
        2,
        4
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "클라우드 스토리지 연동",
          "description": "Configure either AWS S3 or Supabase storage for ring images",
          "dependencies": [],
          "details": "Research and select the appropriate storage solution (S3 or Supabase). Create necessary buckets/containers with proper access permissions. Generate and securely store API keys or credentials. Document the storage structure and access patterns for the team.\n<info added on 2025-05-04T10:21:57.172Z>\nResearch and select the appropriate storage solution (S3 or Supabase). Create necessary buckets/containers with proper access permissions. Generate and securely store API keys or credentials. Document the storage structure and access patterns for the team.\n\n## Supabase Storage 구현 계획\n\n### 스토리지 서비스 선택\n- Supabase Storage를 반지 이미지 저장소로 사용\n\n### 구현 단계\n1. Supabase 프로젝트 생성 및 Storage 서비스 활성화\n2. 'rings' 버킷 생성 (공개 읽기 권한 설정, 업로드 권한은 인증된 사용자로 제한)\n3. 반지 이미지 폴더 구조 설계 및 구현\n   - 경로 형식: /rings/{ringId}/{colorId}.png\n   - 모든 이미지는 탑뷰 PNG 형식으로 통일\n4. 보안 및 인증\n   - Supabase 서비스 키 및 익명 키 발급\n   - .env 파일에 안전하게 키 저장\n5. 클라이언트 연동\n   - Supabase JavaScript SDK 설치\n   - 환경 설정 및 초기화 코드 작성\n   - 이미지 가져오기 유틸리티 함수 구현\n\n### 작업 파일\n- scripts/supabase-init.md: Supabase 설정 가이드 문서\n- public/data/rings.json: 반지 메타데이터 (이미지 경로 포함)\n- .env: Supabase 키 저장\n- src/lib/supabase.ts: Supabase 클라이언트 유틸리티\n\n### 참고 자료\n- Supabase Storage 공식 문서: https://supabase.com/docs/guides/storage\n</info added on 2025-05-04T10:21:57.172Z>",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "이미지 메타데이터 스키마 정의",
          "description": "Create a standardized metadata structure for ring images",
          "dependencies": [
            1
          ],
          "details": "Define metadata fields (ring ID, category, material, style, dimensions, creation date, etc.). Create a JSON schema for validation. Implement naming conventions for files that reflect the metadata structure. Document the schema for team reference.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "이미지 업로드 프로세스 구현",
          "description": "Develop scripts to organize and upload ring images with proper metadata",
          "dependencies": [
            1,
            2
          ],
          "details": "Create scripts to batch process images (resize, optimize, rename). Implement metadata extraction or assignment. Develop upload functionality with error handling and retry logic. Test uploads with various image types and sizes. Document the upload process.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "클라이언트 이미지 캐싱",
          "description": "Develop efficient client-side image loading with proper caching",
          "dependencies": [
            3
          ],
          "details": "Implement API endpoints for retrieving images based on metadata. Create client-side caching strategy (browser cache, IndexedDB, or memory cache). Implement lazy loading for image galleries. Add prefetching for anticipated user navigation. Test performance across different network conditions.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 6,
      "title": "손가락별 반지 합성 및 시뮬레이션",
      "description": "Implement the functionality to overlay selected rings on specific fingers based on user selection, with support for different rings and colors on each finger.",
      "details": "1. Create a data structure to track ring selections for each finger:\n```typescript\ninterface FingerRingSelection {\n  finger: string;\n  ringId: string | null;\n  colorId: string | null;\n}\n\nconst [fingerSelections, setFingerSelections] = useState<FingerRingSelection[]>([\n  { finger: 'thumb', ringId: null, colorId: null },\n  { finger: 'index', ringId: null, colorId: null },\n  { finger: 'middle', ringId: null, colorId: null },\n  { finger: 'ring', ringId: null, colorId: null },\n  { finger: 'pinky', ringId: null, colorId: null },\n]);\n```\n2. Implement a canvas-based overlay system to place rings on fingers:\n```tsx\nconst RingOverlay: React.FC<{\n  handImage: string;\n  fingerPositions: {finger: string, x: number, y: number}[];\n  fingerSelections: FingerRingSelection[];\n  rings: RingInfo[];\n}> = ({ handImage, fingerPositions, fingerSelections, rings }) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    \n    // Load the hand image\n    const img = new Image();\n    img.src = handImage;\n    img.onload = () => {\n      // Set canvas dimensions to match image\n      canvas.width = img.width;\n      canvas.height = img.height;\n      \n      // Draw the hand image\n      ctx.drawImage(img, 0, 0);\n      \n      // Draw rings on fingers\n      fingerSelections.forEach(selection => {\n        if (!selection.ringId || !selection.colorId) return;\n        \n        const fingerPos = fingerPositions.find(fp => fp.finger === selection.finger);\n        if (!fingerPos) return;\n        \n        const ring = rings.find(r => r.id === selection.ringId);\n        if (!ring) return;\n        \n        const color = ring.availableColors.find(c => c.id === selection.colorId);\n        if (!color) return;\n        \n        // Load and draw the ring image at finger position\n        const ringImg = new Image();\n        ringImg.src = color.imageUrl;\n        ringImg.onload = () => {\n          // Calculate position and scale for the ring\n          const ringWidth = ringImg.width * 0.5; // Scale as needed\n          const ringHeight = ringImg.height * 0.5;\n          const x = fingerPos.x * canvas.width - ringWidth / 2;\n          const y = fingerPos.y * canvas.height - ringHeight / 2;\n          \n          ctx.drawImage(ringImg, x, y, ringWidth, ringHeight);\n        };\n      });\n    };\n  }, [handImage, fingerPositions, fingerSelections, rings]);\n  \n  return <canvas ref={canvasRef} className=\"ring-overlay-canvas\" />;\n};\n```\n3. Implement finger pill selection to update active finger\n4. Create a mechanism to update ring selection for specific fingers\n5. Implement automatic thumb selection after initial ring choice\n6. Add visual feedback when a finger is selected\n7. Optimize ring positioning and scaling based on finger size",
      "testStrategy": "1. Test ring overlay with various hand images and finger positions\n2. Verify that different rings can be applied to different fingers\n3. Test changing ring selections for specific fingers\n4. Verify that the visual representation matches the expected outcome\n5. Test with different ring images and colors\n6. Verify that the automatic thumb selection works correctly",
      "priority": "high",
      "dependencies": [
        3,
        5
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "손가락 선택 컴포넌트 개발",
          "description": "Develop the UI component that allows users to select which finger they want to place a ring on",
          "dependencies": [],
          "details": "Build an interactive finger selection interface that clearly shows all available finger options. Include visual indicators for selected fingers, implement touch/click interactions, and ensure the component is accessible. The component should communicate with the state management system when a finger is selected.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "반지 종류 선택 UI 구현",
          "description": "Create the UI for selecting different types of rings available for each finger",
          "dependencies": [
            1
          ],
          "details": "Design and implement a component that displays all available ring types for the selected finger. Include thumbnail images, names, and possibly brief descriptions of each ring type. The interface should update dynamically based on the currently selected finger and communicate selections to the state management system.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "컬러/재질 선택 옵션 구현",
          "description": "Create the UI component for selecting ring colors and materials",
          "dependencies": [
            2
          ],
          "details": "Create a color/material picker that shows available options for the selected ring type. Include visual swatches, material names, and possibly pricing differences. Implement hover/focus states to preview how colors look on the selected ring. Ensure the component integrates with the state management system to track color selections.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "상태 관리 시스템 개발",
          "description": "Implement the state management logic to track all user selections across the ring customization process",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Create a comprehensive state management solution that tracks which fingers have rings, what type of ring is on each finger, and what color/material is selected for each ring. Implement functions to update state when selections change, validate selections, and prepare the final selection data for submission. Include methods for resetting selections and loading previous configurations.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 7,
      "title": "결과 이미지 생성 및 공유 기능",
      "description": "Implement functionality to generate the final image with rings overlaid on fingers and provide options to download or share via Web Share API.",
      "details": "1. Create a function to generate the final image from the canvas:\n```typescript\nconst generateFinalImage = (canvas: HTMLCanvasElement): Promise<Blob> => {\n  return new Promise((resolve, reject) => {\n    canvas.toBlob(blob => {\n      if (blob) {\n        resolve(blob);\n      } else {\n        reject(new Error('Failed to generate image'));\n      }\n    }, 'image/jpeg', 0.95);\n  });\n};\n```\n2. Implement download functionality:\n```typescript\nconst downloadImage = async (canvas: HTMLCanvasElement) => {\n  try {\n    const blob = await generateFinalImage(canvas);\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'haime-lets-try.jpg';\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  } catch (error) {\n    console.error('Failed to download image:', error);\n  }\n};\n```\n3. Implement Web Share API integration:\n```typescript\nconst shareImage = async (canvas: HTMLCanvasElement) => {\n  try {\n    if (!navigator.share) {\n      throw new Error('Web Share API not supported');\n    }\n    \n    const blob = await generateFinalImage(canvas);\n    const file = new File([blob], 'haime-lets-try.jpg', { type: 'image/jpeg' });\n    \n    await navigator.share({\n      title: 'My Ring Try-On from haime',\n      text: 'Check out these rings I tried on with haime lets try!',\n      files: [file]\n    });\n  } catch (error) {\n    console.error('Failed to share image:', error);\n    // Fallback to download if sharing fails\n    downloadImage(canvas);\n  }\n};\n```\n4. Create UI components for download and share buttons\n5. Implement a share sheet for platforms without Web Share API support\n6. Add visual feedback during image generation and sharing\n7. Ensure the final image includes branding elements as specified in the design",
      "testStrategy": "1. Test image generation with various ring combinations\n2. Verify download functionality works across browsers\n3. Test Web Share API on supported platforms\n4. Verify fallback mechanisms work on unsupported platforms\n5. Test image quality and size optimization\n6. Verify that no image data is sent to servers during sharing",
      "priority": "medium",
      "dependencies": [
        6
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "캔버스 렌더링 시스템 구현",
          "description": "Implement a canvas-based rendering system for the ring overlay feature",
          "dependencies": [],
          "details": "Set up an HTML5 canvas element that will be used for rendering the ring overlays. Implement the basic drawing context and initialization functions. Create a rendering loop that can efficiently update the canvas when needed. Include methods for loading and caching ring images to be used as overlays. Establish a basic architecture that separates rendering logic from application logic.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "합성 위치 알고리즘 개발",
          "description": "Develop algorithms to position ring overlays based on finger detection data",
          "dependencies": [
            1
          ],
          "details": "Create algorithms that translate finger detection coordinates to canvas coordinates. Implement logic to determine the correct finger joint for ring placement. Add stabilization techniques to reduce jitter in positioning. Develop methods to handle different hand orientations and positions. Include fallback positioning when finger detection confidence is low.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "스케일/회전 조정 기능",
          "description": "Implement dynamic scaling and rotation of ring overlays based on finger orientation",
          "dependencies": [
            1,
            2
          ],
          "details": "Create algorithms to determine appropriate ring scaling based on detected finger width. Implement rotation adjustments that align rings with finger orientation. Add perspective transformations to match the viewing angle of the finger. Develop smooth transitions when scaling or rotating to prevent visual jumps. Include configuration options for different ring styles and their specific scaling requirements.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "모바일 성능 최적화",
          "description": "Enhance rendering performance and implement z-index layering for realistic appearance",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implement proper z-index handling to ensure rings appear correctly relative to fingers. Add occlusion handling so rings can appear partially hidden by other fingers when appropriate. Optimize canvas operations for mobile GPU performance. Implement resolution scaling based on device capabilities. Add frame rate throttling for lower-end devices. Create performance monitoring tools to identify and address bottlenecks.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 8,
      "title": "개인정보 안내 및 사용자 가이드",
      "description": "Implement privacy notices and user guidance throughout the application to ensure users understand that their hand images are not stored on servers.",
      "details": "1. Create a privacy notice component to be displayed during image upload:\n```tsx\nconst PrivacyNotice: React.FC = () => {\n  return (\n    <div className=\"privacy-notice\">\n      <h3>Privacy Assurance</h3>\n      <p>\n        Your hand image is processed entirely in your browser and is never uploaded or stored on our servers.\n        All image processing happens locally on your device.\n      </p>\n    </div>\n  );\n};\n```\n2. Implement tooltips and guidance text throughout the application\n3. Create a comprehensive help section explaining the process\n4. Add visual indicators showing that processing is happening client-side\n5. Implement a cookie consent banner if necessary\n6. Create a detailed privacy policy page\n7. Add visual cues to reinforce privacy messaging during key user actions",
      "testStrategy": "1. Verify that privacy notices are clearly visible at appropriate points\n2. Test that guidance text is helpful and not intrusive\n3. Conduct user testing to ensure privacy messaging is understood\n4. Verify that no network requests containing image data are made\n5. Test accessibility of privacy notices for screen readers",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "캔버스→이미지 변환 기능",
          "description": "Create functionality to convert the canvas with rings to an image format while adding branding elements",
          "dependencies": [],
          "details": "Use HTML5 Canvas API to export the current canvas state to an image format (PNG/JPEG). Add logo, watermark or other branding elements to the exported image. Ensure the conversion maintains the visual quality of the rings and other elements from the canvas.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "이미지 품질/용량 최적화",
          "description": "Implement techniques to balance image quality with file size for optimal sharing",
          "dependencies": [
            1
          ],
          "details": "Research and implement compression techniques for the exported images. Test different quality settings for JPEG or compression levels for PNG. Create a system that allows adjustable quality settings. Benchmark file sizes and visual quality to find the optimal balance for social media sharing.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "이미지 미리보기 기능",
          "description": "Develop a preview system that shows users how their final image will look before downloading",
          "dependencies": [
            1,
            2
          ],
          "details": "Build a modal or dedicated area in the UI that displays the processed image with all branding elements applied. Ensure the preview accurately represents what users will get when they download. Add options to adjust image settings from the preview if needed.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "다운로드 기능 구현",
          "description": "Create a system for users to download the generated image to their device",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implement a download button that triggers the browser's download functionality. Ensure proper filename generation with appropriate extensions. Add options for different image formats if supported. Consider adding analytics to track download events.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 9,
      "title": "모바일 최적화 및 반응형 UI",
      "description": "Optimize the application for mobile devices, ensuring responsive design and touch-friendly interactions based on the Figma design.",
      "details": "1. Implement responsive layouts using Tailwind CSS breakpoints:\n```tsx\n<div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n  {/* Content */}\n</div>\n```\n2. Optimize touch targets for mobile:\n```css\n.touch-target {\n  min-width: 44px;\n  min-height: 44px;\n}\n```\n3. Implement mobile-specific UI components where needed\n4. Add touch gesture support for ring manipulation\n5. Optimize image processing for mobile performance\n6. Implement progressive loading for better mobile experience\n7. Test and optimize for various mobile screen sizes\n8. Ensure proper viewport settings:\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n```\n9. Implement mobile-friendly error states and loading indicators",
      "testStrategy": "1. Test on various mobile devices and screen sizes\n2. Verify touch interactions work correctly\n3. Measure and optimize performance on mobile devices\n4. Test with throttled network connections\n5. Verify that the UI is usable on small screens\n6. Test with various mobile browsers (Chrome, Safari, Firefox)",
      "priority": "medium",
      "dependencies": [
        5,
        6
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Web Share API 연동",
          "description": "Implement the core sharing functionality using the Web Share API to allow users to share content via their device's native sharing options.",
          "dependencies": [],
          "details": "Research Web Share API specifications and browser compatibility. Create a function that accepts share data (title, text, URL) and triggers the navigator.share() method. Handle promises and errors appropriately. Test on supported browsers and devices.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "브라우저 지원 체크",
          "description": "Implement logic to detect if the Web Share API is supported in the user's browser and prepare for fallback options.",
          "dependencies": [
            1
          ],
          "details": "Create a utility function to check if navigator.share is available. Document browser compatibility information. Set up conditional logic that will determine whether to use the Web Share API or fallback options based on detection results.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "공유 대체 옵션 개발",
          "description": "Create alternative sharing methods for browsers that don't support the Web Share API.",
          "dependencies": [
            2
          ],
          "details": "Implement direct links for common platforms (Twitter, Facebook, LinkedIn, etc.). Create a copy-to-clipboard functionality for the URL. Consider implementing a custom share modal for unsupported browsers. Ensure fallbacks maintain a consistent user experience with the native sharing.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "공유 UI 컴포넌트 구현",
          "description": "Create user interface elements for sharing functionality that work across both Web Share API supported browsers and fallback options.",
          "dependencies": [
            1,
            3
          ],
          "details": "Design share buttons/icons that are intuitive and accessible. Implement tooltips or helper text to guide users. Create responsive UI that works well on mobile and desktop. Ensure the UI adapts based on whether native sharing or fallbacks are being used. Add appropriate visual feedback for share actions.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 10,
      "title": "최종 통합 및 E2E 테스트",
      "description": "Integrate all components into a cohesive application, implement comprehensive error handling, and conduct end-to-end testing.",
      "details": "1. Create the main application component integrating all features:\n```tsx\nconst LetsTriApp: React.FC = () => {\n  const [step, setStep] = useState<'upload' | 'detection' | 'selection'>('upload');\n  const [handImage, setHandImage] = useState<string | null>(null);\n  const [fingerPositions, setFingerPositions] = useState<{finger: string, x: number, y: number}[]>([]);\n  const [activeFingerIndex, setActiveFingerIndex] = useState<number | null>(null);\n  const [fingerSelections, setFingerSelections] = useState<FingerRingSelection[]>([\n    { finger: 'thumb', ringId: null, colorId: null },\n    { finger: 'index', ringId: null, colorId: null },\n    { finger: 'middle', ringId: null, colorId: null },\n    { finger: 'ring', ringId: null, colorId: null },\n    { finger: 'pinky', ringId: null, colorId: null },\n  ]);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  \n  // Handle image upload\n  const handleImageUpload = (imageUrl: string) => {\n    setHandImage(imageUrl);\n    setStep('detection');\n  };\n  \n  // Handle finger detection completion\n  const handleDetectionComplete = (positions: {finger: string, x: number, y: number}[]) => {\n    setFingerPositions(positions);\n    setStep('selection');\n  };\n  \n  // Handle ring selection\n  const handleRingSelection = (ringId: string, colorId: string) => {\n    if (activeFingerIndex === null) {\n      // Default to thumb (index 0) for first selection\n      setActiveFingerIndex(0);\n      setFingerSelections(prev => {\n        const updated = [...prev];\n        updated[0] = { ...updated[0], ringId, colorId };\n        return updated;\n      });\n    } else {\n      setFingerSelections(prev => {\n        const updated = [...prev];\n        updated[activeFingerIndex] = { ...updated[activeFingerIndex], ringId, colorId };\n        return updated;\n      });\n    }\n  };\n  \n  // Handle finger pill selection\n  const handleFingerSelect = (index: number) => {\n    setActiveFingerIndex(index);\n  };\n  \n  // Handle sharing\n  const handleShare = async () => {\n    if (canvasRef.current) {\n      await shareImage(canvasRef.current);\n    }\n  };\n  \n  // Handle download\n  const handleDownload = async () => {\n    if (canvasRef.current) {\n      await downloadImage(canvasRef.current);\n    }\n  };\n  \n  return (\n    <div className=\"lets-try-app\">\n      <header>\n        <h1>haime lets try</h1>\n      </header>\n      \n      <main>\n        {step === 'upload' && (\n          <>\n            <PrivacyNotice />\n            <ImageUpload onUpload={handleImageUpload} />\n          </>\n        )}\n        \n        {step === 'detection' && handImage && (\n          <HandDetection \n            image={handImage} \n            onDetectionComplete={handleDetectionComplete} \n          />\n        )}\n        \n        {step === 'selection' && handImage && fingerPositions.length > 0 && (\n          <>\n            <div className=\"ring-simulation-container\">\n              <RingOverlay \n                handImage={handImage}\n                fingerPositions={fingerPositions}\n                fingerSelections={fingerSelections}\n                rings={rings}\n                canvasRef={canvasRef}\n              />\n              \n              <div className=\"finger-pills\">\n                {fingerPositions.map((pos, index) => (\n                  <FingerPill \n                    key={pos.finger}\n                    finger={pos.finger}\n                    active={activeFingerIndex === index}\n                    hasRing={!!fingerSelections[index].ringId}\n                    onClick={() => handleFingerSelect(index)}\n                  />\n                ))}\n              </div>\n              \n              <button \n                className=\"select-ring-button\"\n                onClick={() => setShowRingModal(true)}\n              >\n                Select Ring\n              </button>\n              \n              <div className=\"name-tag\">\n                {activeFingerIndex !== null && fingerSelections[activeFingerIndex].ringId && (\n                  <p>{getRingName(fingerSelections[activeFingerIndex].ringId)}</p>\n                )}\n              </div>\n              \n              <div className=\"share-actions\">\n                <button onClick={handleDownload}>Download</button>\n                <button onClick={handleShare}>Share</button>\n              </div>\n            </div>\n            \n            <RingSelectionModal \n              isOpen={showRingModal}\n              onClose={() => setShowRingModal(false)}\n              onSelectRing={handleRingSelection}\n            />\n          </>\n        )}\n      </main>\n      \n      <footer>\n        <p>© haime. All rights reserved.</p>\n      </footer>\n    </div>\n  );\n};\n```\n2. Implement comprehensive error handling throughout the application\n3. Add loading states and fallback UI for all async operations\n4. Implement analytics to track user interactions (without collecting personal data)\n5. Create a global error boundary component\n6. Optimize performance with React.memo, useMemo, and useCallback\n7. Implement proper SEO metadata\n8. Add final polish based on Figma design",
      "testStrategy": "1. Conduct end-to-end testing of the complete user flow\n2. Test error scenarios and recovery\n3. Verify that all components work together correctly\n4. Test performance under various conditions\n5. Conduct cross-browser testing\n6. Verify mobile functionality\n7. Test accessibility compliance\n8. Conduct user acceptance testing",
      "priority": "high",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "한/영 개인정보 안내 작성",
          "description": "Develop clear and concise privacy notices in both Korean and English languages that explain data handling practices",
          "dependencies": [],
          "details": "Create privacy notices that clearly communicate what data is collected, how it's used, and emphasize client-side processing. Ensure language is accessible to users with varying technical knowledge. Have both versions reviewed for accuracy, cultural appropriateness, and legal compliance in both languages.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "기술적 보호조치 구현",
          "description": "Develop and implement technical safeguards to ensure client-side-only processing of user data",
          "dependencies": [
            1
          ],
          "details": "Create technical architecture that processes user data exclusively on the client side. Implement encryption for any temporary storage, verify no data is transmitted to servers without explicit consent, and document the implementation for technical review. Include automated tests to verify data containment.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "시각적 개인정보 표시",
          "description": "Design and implement visual indicators that clearly show users when data is being processed locally",
          "dependencies": [
            2
          ],
          "details": "Create intuitive visual cues (icons, badges, or status indicators) that appear when local processing is active. Include tooltips or brief explanations of what these indicators mean. Ensure indicators are accessible and visible across different devices and screen sizes. Test with users to verify understanding.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "개인정보 처리방침 페이지",
          "description": "Create a detailed privacy policy page that incorporates all privacy aspects of the application",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Develop a comprehensive privacy policy page that includes all legal requirements, explains the technical safeguards in place, references the visual indicators, and provides detailed information about data handling practices. Include sections for user rights, data retention policies, and contact information for privacy concerns. Ensure the page is available in both Korean and English.",
          "status": "pending"
        }
      ]
    }
  ]
}